<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="findViewById 控件树中以深度优先遍历每个activity有一个window对象，他将一个decorview作为根view，内容是id为content的framelayout操作window的方法在setcontentview前 测量模式exactly 具体数值和matchparentat_most 是wra">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/11/28/技术整理/高级知识/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="findViewById 控件树中以深度优先遍历每个activity有一个window对象，他将一个decorview作为根view，内容是id为content的framelayout操作window的方法在setcontentview前 测量模式exactly 具体数值和matchparentat_most 是wrapcontentonMeasure只支持exactly模式，所以想要适应自定义v">
<meta property="og:updated_time" content="2017-11-28T08:26:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="findViewById 控件树中以深度优先遍历每个activity有一个window对象，他将一个decorview作为根view，内容是id为content的framelayout操作window的方法在setcontentview前 测量模式exactly 具体数值和matchparentat_most 是wrapcontentonMeasure只支持exactly模式，所以想要适应自定义v">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-技术整理/高级知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/28/技术整理/高级知识/" class="article-date">
  <time datetime="2017-11-28T08:26:16.000Z" itemprop="datePublished">2017-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>findViewById 控件树中以深度优先遍历<br>每个activity有一个window对象，他将一个decorview作为根view，内容是id为content的framelayout<br>操作window的方法在setcontentview前</p>
<p>测量模式<br>exactly 具体数值和matchparent<br>at_most 是wrapcontent<br>onMeasure只支持exactly模式，所以想要适应自定义view的wrapcontent属性需要重写该方法<br>重写onMeasure方法就是为了给wrap_content指定一个默认大小，不指定就是match_parent了<br>在preview里面构建完也能看到<br>measureSpec既包含了测量模式又包含了测量大小</p>
<p>viewgroup把view放在什么位置要重写onLayout方法，需要支持wrapcontent还需要onMeasure，viewgroup不需要绘制，但调用dispatchDraw调用子view的绘制方法</p>
<p>自定义view需要ondraw，onMeasure，和attr</p>
<p>attr用下划线分隔，用完要回收<br>TypedArray a = context.obtainStyledAttributes(R.styleable.Gallery1);int itemBackground = a.getDrawable(R.styleable.Gallery1_android_galleryItemBackground, 0);  a.recycle();</p>
<p>自定义一个actionbar需要先声明attr，然后提供事件监听，隐藏显示，动态改变文字，在xml中写一个固定布局通过include使用</p>
<p>//设置文字居中显示paint3.setTextAlign(Paint.Align.CENTER);</p>
<p>//这个获取屏幕宽高的方法不用activityDisplayMetrics displayMetrics = getResources().getDisplayMetrics();Log.e(“tag”, displayMetrics.widthPixels + “ , “ + displayMetrics.heightPixels);<br>获取android左上角的坐标，getRawXY，getLocationOnSreen<br>获取android相对于父容器左上角的坐标，getXY</p>
<p>事件拦截：<br>ABC，ab是viewgroup，c是view<br>a的dispatchTouchEvent<br>a的onInterceptTouchEvent<br>b的dispatchTouchEvent<br>b的onInterceptTouchEvent<br>c的dispatchTouchEvent<br>c的onTouchEvent<br>b的onTouchEvent<br>a的onTouchEvent</p>
<p>true拦截，false不拦截<br>c要是拦截了就不往上报了</p>
<p>第一行代码看的太快，没有消化完</p>
<p>xhdpi是720p 1dp=2px<br>xxhdpi是1080p 1dp=3px</p>
<p>drawarc可以画弧和扇形，空实心由style控制，2者由usercenter控制<br>layer-list实现ps图层</p>
<p>不支持横屏，每个activity设置属性，禁止旋转<br>onpause要暂停音视频，来电话，多窗口就不行，并且记录播放的位置，继续播放<br>mediaPlayer.pause<br>mediaPlayer.getCurrentPosition<br>mediaPlayer.seekTo(pos)<br>mediaPlayer.start</p>
<p>onDestroy<br>if(mediaPlayer!=null){<br>mediaPlayer.release;<br>mediaPlayer=null;<br>}</p>
<p>intent传递bitmap，大数据0.5M以下才能传过去</p>
<p>singleTop自己启动自己栈顶只调用onNewIntent<br>singleTask也是一样，同时会把他之上的activity全部finish</p>
<p>singleTop和singleTask还是有区别的，后者会把他以上的栈元素都清空</p>
<p>targetVersion小于23就可以不适配权限，compile使用23</p>
<p>proguard不光是混淆，还是精简资源，剔除无用的类</p>
<p>布局优化：<br>gpu过度绘制，增大蓝色，减少红色<br>view树<br>xml中使用viewstub<br>viewstub是延迟加载，调用visiable和inflate时加载出来他就没了，适合网络加载的那种布局</p>
<p>内存优化一般是堆优化：<br>bitmap：图片大小和尺寸处理</p>
<p>adb命令<br>安装 adb install -r /Users/feifei/Downloads/com.delphicoder.flud.apk<br>传输  push pull<br>pm和am命令，要先进shell<br>am start -n com.badou.mworking/com.badou.mworking.model.login.Splashs<br>reboot</p>
<p>刘的技能：</p>
<p>输入命令行，提交git<br>adb安装卸载app<br>分公司构建项目<br>打包aar避免每次构建<br>抓包调试网络<br>窗口view调试器</p>
<p>aligin属性算margin和padding<br>AdapterView获取某个位置的view<br>安卓原生的面包屑fragmentbreadcrumbs<br>viewswitcher2个view间的动画<br>pagerTabStrip是支持库里就有的<br>fragment.setRetainInstance(true);activity重建时仍然保留fragment<br>fragmentTransaction.commitAllowingStateLoss()activity保存状态后还可以提交<br>supportvx表示支持到apix以下<br>annotation告诉调用者期望的参数<br>mipmap只放icon就行了<br>xml引用9patch开启抖动<br>levellist如电量图片，xml中指定maxlevel和对应图片<br>clipdrawable适合进度条裁剪，通过setlevel<br>viewportwidth是看到他的窗口尺寸，和h5一样</p>
<p>vectordrawable是使用path用svg的<br>带动画的矢量drawable<br>创建属性动画，android:propertyName=”pathData”</p>
<p>rippledrawable动画开启了一个线程<br>Reveal动画都是md</p>
<p>设计一个app现在xml中定义全局尺寸，文字颜色<br>定义导航结构，使用materialdesign</p>
<p>这种写法android:textAppearance=”?android:attr/textAppearanceMedium”</p>
<p>viewpager和tablayout绑定起来<br>抽屉导航一开始打开抽屉给用户提示</p>
<p>选择主色调和强调色<br>文字选择字体，大小，间距，对齐，内容多少的变化<br>用图一定要设计图片，质量，大小，显示方式和很重要，图文混排的阅读性：给文字加背景或给图加遮罩，或局部<br>文字区域使用一个模糊的渐变<br>视觉设计：为什么要加模糊效果<br>给xxhdpi设计一套图就行</p>
<p>gridview的clipToPadding设为false</p>
<p>使用toolbar，设置透明，主题去掉actionbar<br>actionBar.setDisplayHomeAsUpEnabled(true);actionBar.setDisplayShowTitleEnabled(false);</p>
<p>属性动画没有指定初始值需要get方法<br>playSequentially依次播放动画</p>
<p>带scrollview的表单错误提示使用smoothScrollTo(0,y)来提示用户<br>textInputLayout.setError(“请输入”)；<br>textInputLayout.setErrorEnable(false);</p>
<p>Scene动画要求id一样，他会找2个场景中那些view是一样的<br>ViewGroup  mSceneRoot = (ViewGroup) findViewById(R.id.scene_root);Scene mScene1 = Scene.getSceneForLayout(mSceneRoot, R.layout.scene1, this);Scene mScene2 = Scene.getSceneForLayout(mSceneRoot, R.layout.scene2, this);<br>Transition mTransition = new ChangeBounds();mTransition.setDuration(DateUtils.SECOND_IN_MILLIS);mTransition.setInterpolator(new AccelerateDecelerateInterpolator());TransitionManager.go(mScene1);Scene mCurrentScene = mScene1;</p>
<p>TransitionManager.go(mScene2, mTransition);mCurrentScene = mScene2;</p>
<p>矢量图标和动画<br>Reveal动画很好创建的，勾股定理算出半径包含边长</p>
<p>图片的矩阵过滤器，合成模式实现淡化效果</p>
<p>自定义view保存和恢复状态<br>invalidate是个一步方法，只是往记录里面添加了一条<br>viewgroup设置setWillNotDraw可以不绘制自己</p>
<p>xml设置id，代码可以用，可以设置tag，用在map里<br>电量使用levellist来写，其中写maxlevel<br>transitondrawable过渡动画<br>insetdrawable加个padding<br>clipdrawable裁剪<br>scaledrawable往小缩</p>
<p>tintmode就是合成模式</p>
<p>使用图片的设计：<br>列表都有图放左边，有的有则放右边，简书<br>文字图片叠加需要遮罩</p>
<p>tools是告诉as的 tools:background<br>在自己声明的方法里使用@stringRes表名需要一个string的int<br>也可以@intDef来定义一个注解，实现枚举的效果</p>
<p>toolbar和drawer关联，不用ActionBarDrawerToggle<br>toolbar.setNavigationIcon(R.drawable.ic_menu_manage);toolbar.setNavigationOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View view) {        drawer.openDrawer(GravityCompat.START);    }});</p>
<p>只想要一个返回按钮的toolbar，设置不显示title并开启导航，背景为透明<br>自定义evaluator的时候要考虑到逼近器会小于0或大于1<br>anticipateInterpolator 弹弓<br>cycleInterpolator 循环<br>overshoot  bounce path</p>
<p>keyframe动画<br>表单提示 smoothScrollTo<br>viewgroup的动画，和xml中加一句话自动产生动画<br>scene用来模拟场景，比如话剧<br>过渡动画使用延迟</p>
<p>自定义一个imageview，内部实现压缩和缓存</p>
<p>为什么说复用很重要，因为申请内存是要连续的，频繁gc会很卡的<br>所以有线程池，这些东西</p>
<p>listview的viewholder作为内部静态类使用就行了<br>文字过度绘制：<br>activity的背景，根布局的背景，list的背景，item的背景</p>
<p>控制垃圾回收：不要在ondraw，onlayout方法里new对象，房子啊构造函数里</p>
<p>HW有view的属性，渲染时间，可以导出为psd这个功能好，程序员可以在ps里设计</p>
<p>自定义drawable获取高度就是textsize<br>itemdecoration的ondrawover是在前景绘制，可以添加多个装饰，getiItemOffsets可以修改view的位置</p>
<p>低版本没有tint方法可以用setColorMatrix设置<br>不变的变量写final更快</p>
<p>invalidate是异步的，记录需要重绘<br>后台线程更新调用postInvalidate</p>
<p>setWillNotDraw()，比如viewgroup调用这个方法<br>保存和恢复状态，继承basesavedstate<br>canvas.drawBitmap(bitmap, 0, 0, paint);表示从左上角开始绘制所有东西<br>space这个控件挺好用的，类似margin</p>
<p>setSystemUiVisivility来控制全屏弱光等模式</p>
<p>wakelock保持屏幕常亮需要权限和释放<br>getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);<br>getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</p>
<p>//判断是否为ui线程<br>if (Looper.myLooper()==Looper.getMainLooper()){}</p>
<p>key可以用hashcode来做，equal就是比较hashcode<br>自定义的viewgroup根布局使用merge就好</p>
<p>attr中的枚举enum和flag</p>
<p>measure代码模板<br> public int measureDimension(int defualtSize,int measureSpec){<br>        int result=defualtSize;<br>       int specMode=MeasureSpec.getMode(measureSpec);<br>       int specSize=MeasureSpec.getSize(measureSpec);  </p>
<pre><code>   //1,layout中自定义组件给出来确定的值，比如100dp  
   //2,layout中自定义组件使用的是match_parent，但父控件的size已经可以确定了，比如设置的具体的值或者match_parent  
  if(specMode==MeasureSpec.EXACTLY){  
        result=specSize;  
   }  
    //layout中自定义组件使用的wrap_content  
    else if(specMode==MeasureSpec.AT_MOST){  
       result=Math.min(defualtSize,specSize);//建议：result不能大于specSize  
    }  
   //UNSPECIFIED,没有任何限制，所以可以设置任何大小  
   else {  
       result=defualtSize;  
    }  
    return result;  
}  
</code></pre><p>通过改变bitmap来使view重绘</p>
<p>ondraw分系统绘制前后</p>
<p>listview取消滚动条<br>listSelector=“@color/transparent” 取消选中状态<br>setSelection(pos)<br>平滑就是 smoothScrollToPosition(pos)</p>
<p>listview实现ios弹性效果只需要修改overScrollBy中的maxOverScrollY值<br>scrollBy在viewGroup中是移动子view，view里是移动内容<br>((View) getParent()).scrollBy(-offsetX, -offsetY);<br>负参数向坐标轴正方向移动，正数向负方向移动</p>
<p>public void computeScroll() {<br>    super.computeScroll();<br>    //是否完成滑动，false说明完成<br>    if (scroller.computeScrollOffset()) {<br>        ((View) getParent()).scrollTo(scroller.getCurrX(), scroller.getCurrY());<br>        //通过重绘来不断调用computeScroll<br>        invalidate();<br>    }<br>}</p>
<p>case MotionEvent.ACTION_UP:<br>    //实现松手后回到原点，scrollTo和scrollBy都是瞬间变化的，没有动画<br>    View v = ((View) getParent());<br>    scroller.startScroll(v.getScrollX(), v.getScrollY(), -v.getScrollX(),-v.getScrollY(), 2000);<br>    invalidate();<br>    break;</p>
<p>canvas save相当于新建图层，restore是合并图层，rotate就像画时钟一样，translate就像移动到圆心一样，只是个辅助绘图工具</p>
<p>图像矩阵rgba和偏移量<br>图像处理有使用hsb的api和矩阵api和像素点api<br>一些效果其实就是常用的矩阵了</p>
<p>bitmap的矩阵变换，一个3*3的矩阵来控制变换<br>translate<br>scale<br>skew<br>rotate<br>也有矩阵的高级api用</p>
<p>矩阵的set会重置，pre和post就不会，前乘和后乘<br>像素块的矩阵处理，drawBitmapMesh，verts计算横纵坐标值<br>通常用srcin和dstin做遮罩，srcin类似做一个圆角图片，实现矢量路径蒙版效果，dstin实现刮刮乐，图片上刷一层渐变的效果</p>
<p>通过合成模式和shader都能实现圆角效果<br>BitmapShader配合一个圆效果就有了</p>
<p>动画也是通过矩阵来实现的，自定义动画就需要实现这个方法<br>path动画其实就是个位移动画，5个图片的</p>
<p>使用camera做动画，rotateY就可以实现3d的效果</p>
<p>protected void applyTransformation(<br>        float interpolatedTime,<br>        Transformation t) {<br>    final Matrix matrix = t.getMatrix();<br>    mCamera.save();<br>    // 使用Camera设置旋转的角度<br>    mCamera.rotateY(mRotateY * interpolatedTime);<br>    // 将旋转变换作用到matrix上<br>    mCamera.getMatrix(matrix);<br>    mCamera.restore();<br>    // 通过pre方法设置矩阵作用前的偏移量来改变旋转中心<br>    matrix.preTranslate(mCenterWidth, mCenterHeight);<br>    matrix.postTranslate(-mCenterWidth, -mCenterHeight);<br>}</p>
<p>singleTop用于比如接受QQ消息的界面<br>singleTask把另一个后台栈都移到前台了<br>singleTop和singleInstance的startActivityForResult会返回cancel，不同的task不能传递数据<br>调用flag on history就不会入栈，直接消失<br>在mainfest可以配置clearTaskOnLaunch是清除其他的act，finishOnTaskLaunch是清除自己</p>
<p>android.os.Build获取系统信息<br>ActivityInfo是manifest下的Activity和receiver<br>ServiceInfo和ApplicationInfo<br>resolveinfo是封装intent信息的</p>
<p>pm = this.getPackageManager();<br>// 获取应用信息<br>List<applicationinfo> listAppcations = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);<br>系统应用 if ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0)<br>第三方应用 if ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0)<br> if ((app.flags &amp;ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0)  系统应用升级后成第三方<br>SD卡应用 if ((app.flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0)</applicationinfo></p>
<p>am获取进程，内存信息，运行的程序和服务<br>MemoryInfo，RunningAppProcessInfo，RunningServiceInfo</p>
<p>List<activitymanager.runningappprocessinfo> appProcessList =<br>        mActivityManager.getRunningAppProcesses();<br>int pid = info.pid;<br>int uid = info.uid;<br>String processName = info.processName;<br>int[] memoryPid = new int[]{pid};<br>Debug.MemoryInfo[] memoryInfo = mActivityManager<br>        .getProcessMemoryInfo(memoryPid);<br>int memorySize = memoryInfo[0].getTotalPss();</activitymanager.runningappprocessinfo></p>
<p>apktools就是一个b和d命令<br>反编译，汉化，重新打包<br>16ms内不丢帧就不会卡顿</p>
<p>gpu柱状图保持在绿线以下，布局边界，过度绘制<br>Relative和merge减少层级</p>
<p>通用ui块把宽高设置为0，这样include的时候自己设置宽高</p>
<p>栈存放基本数据和引用，堆存放对象和数组，通过gc控制<br>bitmap：使用适当的分辨率和大小，及时回收或复用，使用缓存<br>列表使用小图，详情用大图</p>
<p>内存包括寄存器，栈堆，静态存储区域，常量池</p>
<p>静态方法比普通方法快，减少不必要的成员变量和对象，少用枚举和迭代器<br>receiver和传感器的创建销毁，注册解注册<br>使用renderscript和opengl实现复杂绘图</p>
<p>Monitor视图：内存持续增高可能是内存泄漏，内存抖动，突然减少可能是发生了GC</p>
<p>getActionBar().setBackgroundDrawable();<br>//给状态栏设置颜色<br>window.setStatusBarColor();</p>
<p>Z=elevation+translationZ;<br>setTranslationZ来改变阴影效果，做动画<br>tintMode有add，multiply</p>
<p>ripple一种是写个包装的shape，一种是<br>background=“?android:attr/selectableItemBackground”  波纹有界<br>background=“?android:attr/selectableItemBackgroundBorderless” 波纹越界<br>clickable先设置为true</p>
<p>新的Activity转场动画，第一个这么写<br>startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());<br>第二个就需要<br>getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</p>
<pre><code>getWindow().setEnterTransition(new Explode());
getWindow().setEnterTransition(new Slide());
getWindow().setEnterTransition(new Fade());
getWindow().setExitTransition(new Fade());
</code></pre><p>共享动画<br>startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this,<br>                // 创建多个共享元素<br>                Pair.create(view, “share”),<br>                Pair.create(fab, “fab”)).toBundle());</p>
<p>reveal动画一个是中心动画，一个是边界动画(0,0)</p>
<p>点击之后阴影上浮，然后下去的动画</p>
<p>stateListAnimator在selector里面写动画</p>
<selector xmlns:android="http://schemas.android.com/apk/res/android"><br><br>    <item android:state_pressed="true"><br>        <set><br>            <objectanimator android:duration="1000" android:propertyname="rotationX" android:valueto="360" android:valuetype="floatType"><br>        </objectanimator></set><br>    </item><br><br>    <item android:state_pressed="false"><br>        <set><br>            <objectanimator android:duration="1000" android:propertyname="rotationX" android:valueto="0" android:valuetype="floatType"><br>        </objectanimator></set><br>    </item><br></selector>

<p>app:actionViewClass=”android.support.v7.widget.SearchView”<br>app:actionProviderClass=”android.support.v7.widget.ShareActionProvider”</p>
<p>展开和折叠式通知需要借助2个RemoteView，设置为contentView和bigContentView<br>悬挂式弹窗就是一个横幅的展示通知给 build.setFullScreenIntent(pendingIntent, true);<br>显示等级默认public，private是没锁屏才显示，sercet是没有安全锁才显示build.setvisibility</p>
<p>build.setColor</p>
<p>下载进度条，progress.setMax(conn.getContentLength)<br>byte[] buffer =new byte[1024]<br>(len=is.read(buffer))!=-1<br>fos.write(buffer,0,len)</p>
<p>只需要找到相应行为的intent就会写了<br>sim卡变更，每次读取手机seri号或者uiid，不一致就是变更了设备<br>监听重启的广播需要重启权限</p>
<p>通过AM获取RunningServices来判断服务是否在运行<br>程序锁创建了一个服务，死循环里获取顶部的Activity，然后进程休眠<br>am.getRunningTasks(1).get(0).topActivity.getPackageName()<br>然后在程序锁的界面里和服务绑定，停止监控，其实就是加入了一个list而已，一个是程序锁列表，一个是已经通过密码进入的列表</p>
<p>ContentObserver可以观察到变化，不是只查询一次，而之前数据库的操作都换成Provider<br>让密码锁界面不出现在历史记录栈中，同时设置为singleInstance</p>
<p>锁屏后就停止保护了，这是需要一个广播，清空已通过保护应用</p>
<p>短信拦截就是广播，abortBroadCast，同时清除数据库记录<br>tm监听动画，挂断电话endCall需要反射了，清除数据要用到provider的观察者了</p>
<p>listview比如做一个系统和用户2个header就可以通过position来生成view，2个list<br>pos==0  pos&lt;=list1.size()  pos==list1.size()+1<br>这2个view就不能复用了</p>
<p>popwindows一定要设置背景<br>卸载应用只是一个intent</p>
<p>流量也是可以控制的<br>获取packageInfo，筛选出权限含有网络的，取出uid来获取流量信息</p>
<p>代码审核<br>checkstyle优化<br>vm绑定<br>日志库<br>上午说的代码提交 命名 设计 性能<br>todo mvp<br>react native</p>
<p>206<br>301 302<br>地图<br>线程停止 手指缩放 自写底层</p>
<p>事件传递不太一样<br>场景动画<br>注解  库 枚举 多个注解<br>colorres和colorint<br>线程注解 值范围注解 权限 重写 返回值 测试 keep注解</p>
<p>java注解在运行时才是反射<br>实现process<br>apt辅助或者provided</p>
<p>百分比布局<br>arm64v8a兼容v7a<br>ndk单独做一个model<br>使用低sdk的来编译so文件，minsdk，否则低版本装不上<br>全平台abi<br>gradle通用配置</p>
<p>第三方aar引用，全局配置指定目录<br>jcenter上传自己的库，在线引用<br>builder变种 final private static<br>innerbuilder插件dialog imageloader okhttp</p>
<p>anr到桌面，分析原因<br>开启严格模式避免anr debug<br>blockcanary集成</p>
<p>handlerthread还是没搞明白<br>asynctask和线程池<br>loader异步加载数据</p>
<p>数据库敏感相息加密<br>sp加解密</p>
<p>4.2后，方法上加上注解就行<br>4.2以下使用jsprompt通过string传输json通信，定义类方法名，发射调用<br>mvp sdk开发<br>eventbus 组建通信</p>
<p>日志库 文件和网络<br>json库  fastjson logansquare<br>greendao  realm<br>库的重复模块</p>
<p>64k是个bug<br>降低方法<br>第三方库选用评估</p>
<p>开发时aar加速 multidex加速 min21<br>pul和push</p>
<p>webp支持  4.2支持透明<br>转换工具<br>png转9patch<br>过滤<br>资源混淆<br>执行命令行<br>crash获取命令行</p>
<p>rx函数式编程<br>buttrrknife绑定资源<br>对所有view进行set和action操作 属性</p>
<p>系统服务<br>依赖注入 创建对象 构造函数 dagger2<br>kotlin  anko布局<br>reactnative</p>
<p>nuwa热修复 bugly<br>aop aspectj</p>
<p>buck构建</p>
<p>sparsearray代替hashmap<br>二分查找<br>静态内部类handler</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/28/技术整理/高级知识/" data-id="cjajd03qq0013dwllpib5f3fa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/28/技术整理/算法题/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/11/28/My-New-Post/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">My New Post</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/28/监听GPS和网络的广播/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/2月来学习总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/Android从细节提升用户体验/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/Html和Android简单对比/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/Mac配置ADB/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>