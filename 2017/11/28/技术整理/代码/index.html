<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="hashmap映射无序，key只许有一个null 夜间模式视频mvp权限 书写ui看设计稿就想到要复用样式了，style继承theme里面设置 windowContentOverlay是状态栏阴影        @null        @null marterial主题 colorControlActivated c">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/2017/11/28/技术整理/代码/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="hashmap映射无序，key只许有一个null 夜间模式视频mvp权限 书写ui看设计稿就想到要复用样式了，style继承theme里面设置 windowContentOverlay是状态栏阴影        @null        @null marterial主题 colorControlActivated colorControlHighlight View decorView = ge">
<meta property="og:updated_time" content="2017-11-28T08:26:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="hashmap映射无序，key只许有一个null 夜间模式视频mvp权限 书写ui看设计稿就想到要复用样式了，style继承theme里面设置 windowContentOverlay是状态栏阴影        @null        @null marterial主题 colorControlActivated colorControlHighlight View decorView = ge">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-技术整理/代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/28/技术整理/代码/" class="article-date">
  <time datetime="2017-11-28T08:26:16.000Z" itemprop="datePublished">2017-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>hashmap映射无序，key只许有一个null</p>
<p>夜间模式<br>视频<br>mvp<br>权限</p>
<p>书写ui看设计稿就想到要复用样式了，style继承<br>theme里面设置 windowContentOverlay是状态栏阴影<br>        <item name="windowBackground">@null</item><br>        <item name="android:windowContentOverlay">@null</item></p>
<p>marterial主题 colorControlActivated colorControlHighlight</p>
<p>View decorView = getWindow().getDecorView();<br>        //夜间模式<br>        decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);<br>    //隐藏导航栏<br>        decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);<br>        //改变窗口时不要移动布局<br>        decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE);<br>        //全屏，可以设置是否影响actionBar<br>        decorView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_FULLSCREEN);</p>
<p>自定义view也要实现onSizeChanged()  if(w!=oldw || h!=oldh){ 复位参数 }<br>自定义view中构造函数使用this(context,null)  this(context,null,0)<br>绘图使用ps的图层概念</p>
<p>animateLayoutChanges可以在代码里设置5种模式，出现，消失，调整等，LayoutTransition<br>简单的可以自定义adapter<br>listview的emptyview需要写在xml中<br>equals字符串写在前</p>
<p> public void hidesToolbar() {<br>        ViewPropertyAnimator.animate(toolbar).translationY(-toolbar.getHeight())<br>                .setInterpolator(new AccelerateInterpolator(1))<br>                .start();<br>    }</p>
<pre><code>public void showsToolbar() {
    ViewPropertyAnimator.animate(toolbar).translationY(0)
            .setInterpolator(new DecelerateInterpolator(1))
            .start();
}
</code></pre><p>刚去汉图的时候做的列表，多类型，分页的，那个时候真的是</p>
<p>switch只用int或integer<br>long,string 都不能作用于swtich<br>byte,short,char都可以隐含转换为int</p>
<p>ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。</p>
<p>优点：<br>1、系统性能的显著提升。<br>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。<br>3、更长的电池续航能力。<br>4、支持更低的硬件。<br>缺点：<br>1.机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%（不过在应用包中，可执行的代码常常只是一部分。比如最新的 Google+ APK 是 28.3 MB，但是代码只有 6.9 MB。）<br>2.应用的安装时间会变长。</p>
<p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>360插件：正确处理权限<br>常见的五个等级为：<br>前台进程（FOREGROUND_APP_ADJ=0）；<br>可见进程（PERCEPTIBLE_APP_ADJ=2）；<br>服务进程（SERVICE_ADJ=5）；<br>后台进程（CACHED_APP_ADJ=8）；<br>空进程（HIDDEN_APP_MIN_ADJ=15）。</p>
<p>在Android系统中，应用进程停止运行有以下几个原因：</p>
<p>1.用户主动退出；<br>2.Crash异常退出；<br>3.系统通过杀掉进程回收内存。</p>
<p>其中，用户主动退出是合理行为；进程发生Crash后需要重新启动应用(有些情况会自动重启)。系统通过杀掉应用进程回收内存，理论上也是合理的行为。这里我们重点分析第三种情况。</p>
<p>我们知道，Android有一个淘汰机制，即Android系统会根据应用的运行状态设置一个进程的优先级，然后根据系统整体内存使用状态进行调整，当内存占用达到一定阈值时，就需要把一些优先级低的进程杀掉，以保证其他进程能够有足够的内存使用。</p>
<p>但是杀掉应用进程会对体验有较大的影响。如再次打开应用耗时会更长(冷启动)，如果能从最大程序上提高应用进程的存活率，可以提高热启动的概率，减少冷启动的概率，让用户更快进入应用。所以提高应用进程的存活率是非常有意义的。<br>应用进程优先级</p>
<p>在Android系统中，应用进程的优先级(oom_adj值)分为以下等级，不同定义的进程系统采用了不同的管理机制。oom_adj值从-17到16，oom_adj越大，进程优先级越低。</p>
<p>常见的五个等级为：<br>前台进程（FOREGROUND_APP_ADJ=0）；<br>可见进程（PERCEPTIBLE_APP_ADJ=2）；<br>服务进程（SERVICE_ADJ=5）；<br>后台进程（CACHED_APP_ADJ=8）；<br>空进程（HIDDEN_APP_MIN_ADJ=15）。</p>
<p>当内存不足时，进程优先级低的(oom_adj越大的)、占内存大的App进程将会被优先杀掉，系统进程的规则如下：</p>
<p>1.进程优先级设置为PERSISTENT_PROC_ADJ(-12)被杀概率要低。<br>2.进程优先级HEAVY_WEIGHT_APP_ADJ(4)，这种是Activity仅次于主进程，系统认为是高权重进程。<br>3.前台进程FORGROUND_APP_ADJ(0)，前台进程，是指正在前台运行的应用，被杀概率不大。<br>4.进程中没有任何Activity存在会优先被杀。<br>5.空进程最容易被杀。</p>
<p>提高进程优先级进程保活</p>
<p>上述分析可以，可以提高进程优先级使应用在后台的存活时间更长，一般使用以下几种方法实现。</p>
<p>1）网络连接</p>
<p>通过长连接心跳和进程保持通信，使进程保持活动状态，但如果系统内存非常紧张，也有可能被杀。</p>
<p>2）利用系统现有机制</p>
<p>一般可以利用注册系统消息(AlarmReceiver,RootReceiver等)，通过系统消息响应挂起进程。</p>
<p>3）利用SyncAdapter</p>
<p>利用Android系统提供的账号同步机制SyncAdapter，实现进程优先级提高。SyncAdapter是一个系统服务，通过系统的定时器更新应用程序数据ContentProvider，因为Sync服务工作在独立进程，并且由操作系统调度，进程属于核心进程级别，系统不会杀掉，而使用了SyncAdapter的进程优先级本身也会提高，从而降低应用进程被杀的概率。</p>
<p>4）此外，降低应用内存开销是减小进程被系统回收概率的一个非常有效的方法。</p>
<p>应用多进程有什么好处</p>
<p>增加App可用内存</p>
<p>在Android中，默认情况下系统会为每个App分配一定大小的内存。比如从最早的16M到后面的32M或者48M等。具体的内存大小取决于硬件和系统版本。</p>
<p>这些有限的内存对于普通的App还算是够用，但是对于展示大量图片的应用来说，显得实在是捉襟见肘。</p>
<p>仔细研究一下，你会发现原来系统的这个限制是作用于进程的(毕竟进程是作为资源分配的基本单位)。意思就是说，如果一个应用实现多个进程，那么这个应用可以获得更多的内存。</p>
<p>于是，增加App可用内存成了应用多进程的重要原因。</p>
<p>独立于主进程</p>
<p>除了增加App可用内存之外，确保使用多进程，可以独立于主进程，确保某些任务的执行和完成。</p>
<p>举一个简单的例子，之前的一个项目存在退出的功能，其具体实现为杀掉进程。为了保证某些统计数据上报正常，不受当前进程退出的影响，我们可以使用独立的进程来完成。</p>
<p>onStartCommand返回START_STICKY<br>onDestroy中startself<br>Service后台变前置，setForground(true)<br>android:persistent = “true</p>
<p>Android账号和同步机制 </p>
<p>下面看一下如何实现这两个方法 首先要加载apk中的资源：</p>
<p>protected void loadResources() {<br>    try {<br>        AssetManager assetManager = AssetManager.class.newInstance();<br>        Method addAssetPath = assetManager.getClass().getMethod(“addAssetPath”, String.class);<br>        addAssetPath.invoke(assetManager, mDexPath);<br>        mAssetManager = assetManager;<br>    } catch (Exception e) {<br>        e.printStackTrace();<br>    }<br>    Resources superRes = super.getResources();<br>    mResources = new Resources(mAssetManager, superRes.getDisplayMetrics(),<br>            superRes.getConfiguration());<br>    mTheme = mResources.newTheme();<br>    mTheme.setTo(super.getTheme());<br>}</p>
<p>说明：加载的方法是通过反射，通过调用AssetManager中的addAssetPath方法，我们可以将一个apk中的资源加载到Resources中，由于addAssetPath是隐藏api我们无法直接调用，所以只能通过反射，下面是它的声明，通过注释我们可以看出，传递的路径可以是zip文件也可以是一个资源目录，而apk就是一个zip，所以直接将apk的路径传给它，资源就加载到AssetManager中了，然后再通过AssetManager来创建一个新的Resources对象，这个对象就是我们可以使用的apk中的资源了，这样我们的问题就解决了。</p>
<pre><code>//第一种方式：  
Classc1 = Class.forName(&quot;Employee&quot;);  

//第二种方式：  
//java中每个类型都有class 属性.  
Classc2 = Employee.class;  

//第三种方式：  
//java语言中任何一个java对象都有getClass 方法  
Employeee = new Employee();  
Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)  
</code></pre><p>Objecto = c.newInstance(); //调用了Employee的无参数构造方法. </p>
<p> //获取id属性<br>    Field idF = c.getDeclaredField(“id”);<br>    //实例化这个类赋给o<br>    Object o = c.newInstance();<br>    //打破封装<br>    idF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。<br>    //给o对象的id属性赋值”110”<br>    idF.set(o, “110”); //set </p>
<p>我们知道了在Service等非Activity的Context里面启动Activity为什么需要添加FLAG_ACTIVITY_NEW_TASK；</p>
<p>私有或者隐藏的API可以使用，但必须处理好兼容性问题<br>renderscript</p>
<p>git_android_dev2@115.28.230.86:/data/git/android</p>
<p>左移是乘，右移是除<br>java高级</p>
<p>List  set方法 isEmpty</p>
<p>fragment写在viewcreater<br>点赞要成功</p>
<p> try {<br>                if ( Environment.getExternalStorageState ().equals(<br>                        Environment.MEDIA_MOUNTED)) {<br>                    URL url2 = new URL (url);<br>                    // 创建连接<br>                    HttpURLConnection conn = (HttpURLConnection) url2<br>                            .openConnection();<br>                    conn.connect();<br>                    int length = conn.getContentLength();// 获取文件大小<br>                    InputStream is = conn.getInputStream();// 创建输入流<br>                    File fileDir = new File (savePath);<br>                    if (!fileDir.exists()) {<br>                        fileDir.mkdirs();<br>                    }<br>                    File apkFile = new File (savePath, “sanguo.apk”);<br>                    if (!apkFile.exists()) {<br>                        apkFile.createNewFile();<br>                    }<br>                    FileOutputStream fos = new FileOutputStream (apkFile);<br>                    int count = 0;<br>                    byte buf[] = new byte[1024];<br>                    do {<br>                        int numread = is.read(buf);<br>                        count += numread;<br>                        progress = (int) (((float) count / length) * 100);// 计算进度条位置<br>                        handler.sendEmptyMessage(DOWNLOAD);// 更新进度<br>                        if (numread &lt;= 0) { // 下载完成<br>                            handler.sendEmptyMessage(DOWNLOAD_FINISH);<br>                            break;<br>                        }<br>                        fos.write(buf, 0, numread);<br>                    } while (true);<br>                    fos.close();<br>                    is.close();<br>                }<br>            } catch (Exception e) {<br>                e.printStackTrace();<br>                handler.sendEmptyMessage(DOWNLOAD_ERROR);<br>            }</p>
<p>延迟1秒弹出键盘来，从下往上弹的效果，配合tint实现状态栏沉浸，从下往上弹的效果很不错<br>public abstract class SearchBaseActivity<t> extends ListBaseActivity<t><br>        tempString = s;</t></t></p>
<p>我原来的状态栏沉浸用的是tint<br>listview和scrollview增加弹性效果</p>
<p>//压缩好比例大小后再进行质量压缩<br>  private Bitmap compressImage(Bitmap image) {</p>
<pre><code>    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中
    int options = 100;
    while (baos.toByteArray().length / 1024 &gt; 100) {  //循环判断如果压缩后图片是否大于100kb,大于继续压缩
        baos.reset();//重置baos即清空baos
        image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中
        options -= 10;//每次都减少10
    }
    ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中
    Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片
    return bitmap;
}
</code></pre><p>土地管理是先插在本地数据库，然后手动同步到服务器或者自动同步上去<br>离线地图开发</p>
<p>圆形按钮效果<br>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<selector xmlns:android="http://schemas.android.com/apk/res/android" ;="" android:exitfadeduration="@android:integer/config_shortAnimTime"><br>    <item android:state_pressed="true"><br>        <shape android:shape="oval" android:uselevel="false"><br>            <solid android:color="@color/yigreen_pressed"><br>            <!--<stroke--><br>            <!--android:width="1dp"--><br>            <a href="&#109;&#97;&#105;&#x6c;&#116;&#111;&#58;&#x21;&#x2d;&#45;&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#x3a;&#x63;&#x6f;&#x6c;&#x6f;&#114;&#x3d;&#34;&#64;&#99;&#111;&#108;&#111;&#x72;&#x2f;&#103;&#x72;&#101;&#x65;&#x6e;&#x22;&#47;">&#x21;&#x2d;&#45;&#x61;&#x6e;&#x64;&#x72;&#x6f;&#x69;&#x64;&#x3a;&#x63;&#x6f;&#x6c;&#x6f;&#114;&#x3d;&#34;&#64;&#99;&#111;&#108;&#111;&#x72;&#x2f;&#103;&#x72;&#101;&#x65;&#x6e;&#x22;&#47;</a>–&gt;<br>            <size android:width="8dp" android:height="8dp"><br>        </size></solid></shape><br>    </item><br>    <item><br>        <shape android:shape="oval" android:uselevel="false"><br>            <solid android:color="@color/colorPrimary"><br>            <!--<stroke--><br>            <!--android:width="1dp"--><br>            <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#58;&#33;&#x2d;&#x2d;&#x61;&#110;&#100;&#x72;&#111;&#x69;&#100;&#58;&#99;&#x6f;&#108;&#x6f;&#114;&#61;&#x22;&#64;&#99;&#x6f;&#x6c;&#111;&#114;&#47;&#x67;&#x72;&#x65;&#101;&#x6e;&#x22;&#47;">&#33;&#x2d;&#x2d;&#x61;&#110;&#100;&#x72;&#111;&#x69;&#100;&#58;&#99;&#x6f;&#108;&#x6f;&#114;&#61;&#x22;&#64;&#99;&#x6f;&#x6c;&#111;&#114;&#47;&#x67;&#x72;&#x65;&#101;&#x6e;&#x22;&#47;</a>–&gt;<br>            <size android:width="8dp" android:height="8dp"><br>        </size></solid></shape><br>    </item><br></selector>

<p>开始下载，取不到city就不行<br>city = location.getCity();<br> ArrayList<mkolsearchrecord> records = mOffline.searchCity(city);<br>                if (records != null &amp;&amp; records.size() != 0) {<br>                    int cityid = Integer.parseInt(String.valueOf(records.get(0).cityID));<br>                    mOffline.start(cityid);<br>                } else {<br>                    TS.t(mActivity, “暂无该城市的离线地图”);<br>                }</mkolsearchrecord></p>
<p>下载进度<br>case MKOfflineMap.TYPE_DOWNLOAD_UPDATE: {<br>                MKOLUpdateElement update = mOffline.getUpdateInfo(state);<br>                // 处理下载进度更新提示<br>                if (update != null) {<br>                    dialog.setProgress(update.ratio);<br>                    dialog.setContent(city + “离线地图下载中”);<br>                    if (update.ratio == 100) {<br>                        dialog.setContent(city + “离线地图下载完成”);<br>                        TS.t(mActivity, “离线地图下载完成”);<br>                        dialog.dismiss();<br>                        updateView();<br>                    }<br>                }<br>            }<br>break;</p>
<p>  mMapView.showScaleControl(false);<br>        mMapView.showZoomControls(false);<br>        mBaiduMap.setMyLocationEnabled(true);<br>        // 定位初始化<br>        mLocClient = new LocationClient(this);<br>        mLocClient.registerLocationListener(myListener);<br>        LocationClientOption option = new LocationClientOption();<br>        option.setOpenGps(true);// 打开gps<br>        option.setCoorType(“bd09ll”); // 设置坐标类型<br>        option.setScanSpan(1000);<br>        //这句和离线地图<br>    option.setIsNeedAddress (true);<br>        mLocClient.setLocOption(option);<br>        mLocClient.start();</p>
<p> @Override<br> public void onReceiveLocation(BDLocation location) {<br> if (!one) {<br>            //la纬度 lo经度<br>            la = location.getLatitude();<br>            lo = location.getLongitude();<br>            if (la != 0 &amp;&amp; lo != 0) {<br>                // 构造定位数据<br>                locData = new MyLocationData.Builder()<br>                        // 定位经度<br>                        .accuracy(location.getRadius())<br>                                // 此处设置开发者获取到的方向信息，顺时针0-360<br>                        .direction(location.getDirection())<br>                        .latitude(location.getLatitude())<br>                        .longitude(location.getLongitude()).build();<br>                // 设置缩放<br>                mMapStatus = new MapStatus.Builder()<br>                        .target(new LatLng(location.getLatitude(), location<br>                                .getLongitude())).zoom(16).build();<br>                mBaiduMap.setMyLocationData(locData);<br>                MapStatusUpdate mMapStatusUpdate = MapStatusUpdateFactory<br>                        .newMapStatus(mMapStatus);<br>                // 改变地图状态<br>                mBaiduMap.setMapStatus(mMapStatusUpdate);<br>                //                Tools.toast (mActivity, la + “”, lo + “”, location.getCity ());</p>
<p> //定位会弄2次<br> one = true;<br>            }<br>        }<br> }</p>
<p>长按返回数据点，定位，离线地图管理<br>  mBaiduMap.setOnMapLongClickListener(new BaiduMap.OnMapLongClickListener() {<br>            public void onMapLongClick(LatLng point) {<br>                if (point != null &amp;&amp; point.latitude != 0 &amp;&amp; point.longitude != 0) {<br>                    Intent intent = new Intent();<br>                    intent.putExtra(“la”, point.latitude);<br>                    intent.putExtra(“lo”, point.longitude);<br>                    // TODO: 2016/1/18 0018<br>                    setResult(LandDetailActivity.RESULT_OK, intent);<br>                    AnimUtil.animBackFinish(mActivity);<br>                } else {<br>                    TS.t(mActivity, “请重新长按”);<br>                }<br>            }<br>        });</p>
<p>  android:fitsSystemWindows=”true”<br>UUID.randomUUID().toString();</p>
<p>曾经学习的bmob，直播，md的写的app，冬天和夏天</p>
<p> recycleView.setHasFixedSize(true);</p>
<p>  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {<br>            Slide transition = new Slide();<br>            transition.excludeTarget(android.R.id.statusBarBackground, true);<br>            getWindow().setEnterTransition(transition);<br>            getWindow().setReturnTransition(transition);<br>        }</p>
<p>聊天列表根据type去inflate不同的布局</p>
<p> //标准snackbar的使用<br>    public static void tip(Activity activity, CharSequence string) {<br>        if (activity != null) {<br>            View view = activity.getWindow().getDecorView().getRootView();<br>//            activity.findViewById(R.id.activity_base_container)<br>            if (activity.getWindow().peekDecorView() != null) {<br>                InputMethodManager inputmanger = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);<br>                inputmanger.hideSoftInputFromWindow(view.getWindowToken(), 0);<br>            }<br>            Snackbar sb = Snackbar.make(view, string, Snackbar.LENGTH_SHORT);<br>            sb.setText(string);<br>            Snackbar.SnackbarLayout sbView = (Snackbar.SnackbarLayout) sb.getView();<br>//            sbView.setBackgroundColor(view.getResources().getColor(R.color.colorPrimary));<br>            TextView textView = (TextView) sbView.findViewById(R.id.snackbar_text);<br>//            textView.setTextColor(Color.WHITE);<br>            textView.setTextSize(18);<br>            textView.setGravity(Gravity.CENTER);<br>            sbView.setPadding(0, 60, 0, 0);<br>            sb.show();<br>        }<br>    }</p>
<p> webView.addJavascriptInterface(new PayJavaScriptInterface(), “pay”);<br>        webView.setWebViewClient(new WebViewClient() {<br>            public boolean shouldOverrideUrlLoading(WebView view, String url) {<br>                //这是在捕捉网页中的电话链接<br>                if (phone) {<br>                    Intent intent = new Intent(Intent.ACTION_DIAL, Uri<br>                            .parse(“tel:” + url));<br>                    getActivity().startActivity(intent);<br>                } else {<br>                    progressBar.setVisibility(View.VISIBLE);<br>                    webView.loadUrl(url);<br>                }<br>                return true;<br>            }<br>        });<br>        // 设置进度条<br>        webView.setWebChromeClient(new WebChromeClient() {<br>            @Override<br>            public void onProgressChanged(WebView view, int newProgress) {<br>                progressBar.setProgress(newProgress);<br>                if (newProgress == 100) {<br>                    progressBar.setVisibility(View.GONE);<br>                }<br>                super.onProgressChanged(view, newProgress);<br>            }<br>        });</p>
<p> public class PayJavaScriptInterface {<br>        PayJavaScriptInterface() {<br>        }</p>
<pre><code>@JavascriptInterface
public String clickOnAndroid(String[] js) {
    if (StringUtil.isEmpty(S.readString(mActivity, MyConst.KEY_MEMBERID, &quot;&quot;))) {
        AnimUtil.animToBottom(mActivity);
    }
</code></pre><p>//            Tools.dialog(mActivity, “你要购买” + js[0] + “,\n” + “口味是” + js[1] + “,一共是” + js[2] + “元”, true, null);<br>            return “成功添加到购物车”;<br>        }<br>    }</p>
<p>音频 字节流<br>录音 播放的采样率不一样</p>
<p>supertoast的撤销的回调<br>dbHelper.delete(bean2.getId());<br>                list.remove(position);<br>                adapter.notifyDataSetChanged();<br>                toast.setOnClickWrapper(new OnClickWrapper(“1”, new SuperToast.OnClickListener() {</p>
<pre><code>    @Override
    public void onClick(View view, Parcelable token) {
        if (token != null) {
            dbHelper.insert((TODO) token);
            list.add(position, bean2);
            adapter.notifyDataSetChanged();
        }
    }

}), bean2);
</code></pre><p> if (bean.isdone()) {<br>            text.setTextColor(Color.GRAY);<br>            text.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG);//删除线<br>        } else {<br>            text.setTextColor(Color.parseColor(“#01579b”));<br>            text.getPaint().setFlags(Paint.LINEAR_TEXT_FLAG);//恢复正常<br>        }</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/28/技术整理/代码/" data-id="cjajd03qh000tdwllmwrmwxt3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/28/技术整理/java/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2017/11/28/技术整理/前端/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/28/监听GPS和网络的广播/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/2月来学习总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/Android从细节提升用户体验/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/Html和Android简单对比/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/11/28/Mac配置ADB/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>